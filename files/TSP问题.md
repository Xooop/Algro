## TSP问题（旅行商问题）
> 旅行商问题：现在有 N 个城市，商人从城市 A 出发，求出从 A 出发经过其他所有城市之后再回到 A 城市的最小代价，要求每个城市只经过一次。

TSP问题是经典NP问题，这里我们讲的是他的动规解法，也就意味着当数据量变大之后，
便不能使用动规这种解法了，但考虑实际遇到的都是数据量小的情况，所以只了解动规解法就行了。

既然是动规解法，那么就需要找出递推关系式，定义出发城市为A, 以及 
dp[i]{1,2,3...n}为从 i 这个城市出发，经过 1,2,3...n 所有城市再回到出发城市 A 的
代价，所以其实我们最后求的是 dp[A]{其他所有城市}的最小值。
到这可以考虑几个特殊情况：
1. 当出发城市包含在需要经过的城市时， 即 dp[1]{1,2,3} = dp[1]{2,3}
2. 当没有需要经过的城市时，那么dp的值即从当前出发城市回A点的代价，
即dp[1]{} = distance[1][A]
状态方程:
dp[i]{S} = min(distance[i][x] + dp[x]{S - {x}}) 其中S为一个集合，
x 为 S 集合中任意一个元素，对S中每个元素进行遍历，最后取最小值

既然递归方程已经给出来了，可以发现dp后一维是一个集合，编码的时候如何表达这种情况？
当然可以使用list去表示，但其实有更巧妙的方法 -> 使用一个具有 N 位的二进制表示,
某一位为 1 代表在集合中。接下来就可以来编码了。

```
    public static double tsp_solution(double[][] distance) {
        // 这里我们默认从城市 0 出发去到其他城市
        // 所以只需要 所有城市数量 - 1 行，因为状态采用二进制的原因，所以有 1 << N 种情况（0 - N个1）
        int N = distance.length - 1; int M = 1 << N;
        double[][] dp = new double[N][M];
        // i 为二进制状态，这是对状态的遍历
        for (int i = 0; i < M; i++) {
            // 每个状态下的，从 j 这个城市出发的代价
            for (int j = 0; j < N; j++) {
                // i1 -> j 对应城市在 distance 中的 idx
                // s1 -> j 对应城市的二进制状态
                int i1 = j + 1; int s1 = 1 << j;
                // i 为 0 代表上述第二种特殊情况
                if (i == 0) {
                    dp[j][i] = distance[i1][0];
                }
                // 上述第一种特殊情况
                if ((i & s1) != 0) {
                    dp[j][i] = dp[j][i - s1];
                    continue;
                }
                // 递归表达式：遍历状态中每个在状态 i 中有的城市，求出最小值
                for (int k = 0; k < N; k++) {
                    int i2 = k + 1; int s2 = 1 << k;
                    if ((i & s2) != 0) {
                        dp[j][i] = Math.min(dp[j][i] == 0.0 ? Double.MAX_VALUE : dp[j][i],
                                dp[k][i - s2] + distance[i1][i2]);
                    }
                }

            }
        }
        // 最后将出发城市到其他点的代价 + dp[i]{S} 再取最小值即为所求，
        // S 为除了出发城市其他所有城市的集合，i 为 S 中的一个城市
        double min = Double.MAX_VALUE;
        for (int i = 0; i < N; i++) {
            int idx = i + 1;
            min = Math.min(dp[i][M - 1] + distance[0][idx], min);
        }
        return min;
    }

```